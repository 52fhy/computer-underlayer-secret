# 22.彻底理解零拷贝

计算机处理的任务大体可以分为两类：CPU密集型与IO密集型。&#x20;

所谓CPU密集型就好比程序员，天天坐在办公室里闷头写代码不怎么需要与外界交互(CPU计算)；而IO密集型更像是销售，几乎不怎么呆在办公室里，需要不断与外界沟通交流(输入输出)。&#x20;

对于程序员来说哪类更容易应对呢？显然是CPU密集型，原因也很简单，CPU密集型任务通常大部分时间都在用户态(呆在办公室里），很少涉及底层，像操作系统以及硬件等，因此程序的运行行为更容易被程序掌控。&#x20;

而与CPU密集型相对于的，IO密集型任务花在用户态的时间相对更少，这类任务更多的需要操作系统的协助（与其它人交互），也就是花在内核态的时间更多，由于IO密集型任务涉及两部分软件：用户态的应用程序与内核态的操作系统，因此程序的运行行为对程序员来说控制力有限。&#x20;

注意，用户态受程序员控制，内核态受操作系统控制，关于用户态内核态的更详尽讲解参见博主的深入理解操作系统一书，关注公众号码农的荒岛求生并操作系统即可。&#x20;

然而不巧的是，当前流行的互联网技术其实也就是网络应用，更多的属于IO密集型，涉及：软件部分的操作系统与数据库，以及硬件部分的磁盘与网络，这些软硬件显然是在内核态，用户态部分只是冰山一角。**当遇到IO后，多线程的魔法就消失了，因为相对于CPU速度来说，瓶颈往往出现在IO设备上，这时候任意你有再多核再多线程都没有用了**。&#x20;

传统的IO标准接口都是基于数据拷贝的，这篇文章我们主要关注该怎样从数据拷贝的角度来优化IO操作。&#x20;

## 为什么IO接口要基于数据拷贝？&#x20;

为了让广大码农们更好的沉迷于自己的一亩三分地，防止ta们分心去关心计算机中的硬件资源分配问题，操作系统诞生了。

操作系统本质上就是一个管家，**目的就是更加公平合理的给各个进程分配硬件资源**，在操作系统出现之前，程序员需要直面各类硬件，就像这样：

![](.gitbook/assets/22\_1.jpg)

在这一时期程序员真可谓掌控全局，掌控全局带来的后果就是你需要掌控所有细节，这显然不利于生产力的释放。&#x20;

操作系统应用而生。&#x20;

现在计算机系统就变成这样了：

![](.gitbook/assets/22\_2.jpg)

现在应用程序不需要和硬件直接交互了，仅从IO的角度上看，操作系统变成了一个类似路由器的角色，把应用程序递交过来的数据分发到具体的硬件上去，或者从硬件接收数据并分发给相应的进程。&#x20;

数据传递是通过什么呢？就是我们常说的buffer，所谓buffer就是一块可用的内存空间，用来暂存数据。

![](.gitbook/assets/22\_3.jpg)

操作系统这一中间商导致的问题就是：你需要**首先把东西交给操作系统，操作系统再转手交给硬件**，这就必然涉及到数据拷贝。&#x20;

这就是为什么传统的IO操作必然需要进行数据拷贝的原因所在。&#x20;

有的同学可能不以为意，不就是数据拷贝吗？应该很快吧！&#x20;

要知道数据拷贝不只涉及CPU一个模块，还包括内存、总线，在CPU看来，内存是一个非常低速的设备，让CPU去完成数据拷贝这样的任务就是在浪费人才，幸好现代计算机系统中普遍采用DMA技术，这类技术可以在没有CPU的参与下实现软件和硬件之间的数据拷贝，从而减轻CPU负担，然而用户态和内核态这类软件和软件之间的数据拷贝则无此机制，在这种情况下数据拷贝依然需要CPU的参与。&#x20;

现状就是这样的，接下来我们用一个实例来让大家对该问题有一个更直观的认知。&#x20;

## 网络服务器&#x20;

有些网络服务器其实是非常简单的，浏览器打开一个网页其实是需要很多数据的，包括看到的图片、html文件、css文件、js文件等等，这些文件的内容可能是不怎么改变的，那么当浏览器请求这类文件时服务器端的工作其实是非常简单：服务器只需要从磁盘中抓出该文件然后丢给网络发送出去就好 了。

![](.gitbook/assets/22\_4.jpg)

代码基本上类似这样：

```
read(fileDesc, buf, len);
write(socket, buf, len);
```

这两段代码非常简单，第一行代码从文件中读取数据存放在buf中，然后将buf中的数据通过网络发送出去。&#x20;

注意观察buf，服务器全程没有对buf中的数据进行任何修改，buf里数据在用户态逛了一圈后挥一挥衣袖没有带走半点云彩就回到了内核态。&#x20;

这两行看似简单的代码实际上在底层发生了什么呢？&#x20;

答案是这样的：

![](.gitbook/assets/22\_5.jpg)

在程序看来简单的两行代码在底层是比较复杂的，看到这张图你应该真心感激操作系统，操作系统就像一个无比称职的管家，替你把所有脏活累活都承担下来，好让你悠闲的在用户态指点江山。&#x20;

这简单的两行代码涉及：**四次数据拷贝**以及**四次上下文切换**：

![](.gitbook/assets/22\_6.jpg)

1. read函数会涉及一次用户态到内核态的切换，操作系统会向磁盘发起一次IO请求，当数据准备好后通过DMA技术把数据拷贝到内核的buffer中，注意本次数据拷贝无需CPU参与。
2. 此后操作系统开始把这块数据从内核拷贝到用户态的buffer中，此时read()函数返回，并从内核态切换回用户态，到这时read(fileDesc, buf, len);这行代码就返回了，buf中装好了新鲜出炉的数据。
3. 记下来send函数再次导致用户态与内核态的切换，此时数据需要从用户态buf拷贝到网络协议子系统的buf中，具体点该buf属于在代码中使用的这个socket。&#x20;
4. 4\. 此后send函数返回，再次由内核态返回到用户态；此时在程序员看来数据已经成功发出去了，但实际数据依然停留在内核中，此后第四次数据copy开始，利用DMA技术把数据从socket buf拷贝给网卡，然后真正的发送出去。&#x20;

这就是看似简单的这两行代码在底层的完整过程。&#x20;

你觉得这个过程有什么问题吗？

## 发现问题&#x20;

有的同学肯定已经注意到了，既然在用户态没有对数据进行任何修改，那为什么要这么麻烦的让数据在用户态来个一日游呢？直接在内核态从磁盘给到网卡不就可以了吗？&#x20;

恭喜你，答对了！

这种优化思路就是所谓的零拷贝技术，Zero Copy。&#x20;

总体上来看，数据拷贝会有以下三种情况：

**1.**用户态不需要真正的去访问数据，就像上面这个示例，用户态根本不需要知道buf里面装的是什么。在这种情况下无需把数据从内核态拷贝到用户态然后再把数据从用户态拷贝会内核态。 数据无需用户态感知，数据拷贝完全发生在内核态。

![](.gitbook/assets/22\_7.jpg)

2.内核态不要真正的去访问数据，用户态程序可以绕过内核直接和硬件交互，这样就避免了内核的参与，从而减少数据拷贝的可能。&#x20;

内核无需感知数据。

![](.gitbook/assets/22\_8.jpg)

3.如果内核态和用户态不得不进行数据交互，则优化用户态与内核态数据的交互方式，有的同学可 能会问，除了数据拷贝难道还有其它交互方式吗？答案是肯定的，接下来你会看到。&#x20;

知道了解决问题的思路，我们来看下为了实现零拷贝，计算机系统中都有哪些巧妙的设计。














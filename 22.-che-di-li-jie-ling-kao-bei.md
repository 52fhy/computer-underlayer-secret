# 22.彻底理解零拷贝

计算机处理的任务大体可以分为两类：CPU密集型与IO密集型。&#x20;

所谓CPU密集型就好比程序员，天天坐在办公室里闷头写代码不怎么需要与外界交互(CPU计算)；而IO密集型更像是销售，几乎不怎么呆在办公室里，需要不断与外界沟通交流(输入输出)。&#x20;

对于程序员来说哪类更容易应对呢？显然是CPU密集型，原因也很简单，CPU密集型任务通常大部分时间都在用户态(呆在办公室里），很少涉及底层，像操作系统以及硬件等，因此程序的运行行为更容易被程序掌控。&#x20;

而与CPU密集型相对于的，IO密集型任务花在用户态的时间相对更少，这类任务更多的需要操作系统的协助（与其它人交互），也就是花在内核态的时间更多，由于IO密集型任务涉及两部分软件：用户态的应用程序与内核态的操作系统，因此程序的运行行为对程序员来说控制力有限。&#x20;

注意，用户态受程序员控制，内核态受操作系统控制，关于用户态内核态的更详尽讲解参见博主的深入理解操作系统一书，关注公众号码农的荒岛求生并操作系统即可。&#x20;

然而不巧的是，当前流行的互联网技术其实也就是网络应用，更多的属于IO密集型，涉及：软件部分的操作系统与数据库，以及硬件部分的磁盘与网络，这些软硬件显然是在内核态，用户态部分只是冰山一角。**当遇到IO后，多线程的魔法就消失了，因为相对于CPU速度来说，瓶颈往往出现在IO设备上，这时候任意你有再多核再多线程都没有用了**。&#x20;

传统的IO标准接口都是基于数据拷贝的，这篇文章我们主要关注该怎样从数据拷贝的角度来优化IO操作。&#x20;

## 为什么IO接口要基于数据拷贝？&#x20;

为了让广大码农们更好的沉迷于自己的一亩三分地，防止ta们分心去关心计算机中的硬件资源分配问题，操作系统诞生了。

操作系统本质上就是一个管家，**目的就是更加公平合理的给各个进程分配硬件资源**，在操作系统出现之前，程序员需要直面各类硬件，就像这样：

![](.gitbook/assets/22\_1.jpg)

在这一时期程序员真可谓掌控全局，掌控全局带来的后果就是你需要掌控所有细节，这显然不利于生产力的释放。&#x20;

操作系统应用而生。&#x20;

现在计算机系统就变成这样了：

![](.gitbook/assets/22\_2.jpg)

现在应用程序不需要和硬件直接交互了，仅从IO的角度上看，操作系统变成了一个类似路由器的角色，把应用程序递交过来的数据分发到具体的硬件上去，或者从硬件接收数据并分发给相应的进程。&#x20;

数据传递是通过什么呢？就是我们常说的buffer，所谓buffer就是一块可用的内存空间，用来暂存数据。

![](.gitbook/assets/22\_3.jpg)
















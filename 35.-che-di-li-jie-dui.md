# 35.彻底理解堆

在计算机科学中堆是一种很有趣的数据结构，实际上通常用数组来存储堆中的元素，但是我们却可以把数组中元素视为树，如图所示：

![](.gitbook/assets/35\_1.jpg)

这就是一个普通的数组，但是我们可以将其看做如下图所示的树：

![](.gitbook/assets/35\_2.jpg)

这是怎么做到的呢？&#x20;

原来虽然我们是在数组中存储的堆元素，但是这里面有一条隐藏的规律，如果你仔细看上图就会发现：&#x20;

* **每一个左子树节点的下标是父节点的2倍**
* **每一个右子树节点的下标是父节点的2倍再加1**&#x20;

也就是说在数组中实际上隐藏了上面的这两条规律，如图所示：

![](.gitbook/assets/35\_3.jpg)

**堆这种数据结构最棒的地方在于我们无需像树一样存储左右子树的信息**，而只需要通过下标运算就可以轻松的找到一个节点的左子树节点、右子树节点以及父节点，如下所示，相对于树这种数据结构来说堆更加节省内存。

```
int parent(int i){ // 计算给定下标的父节点
 return i/2;
}
int left(int i){ // 计算给定下标的左子树节点
 return 2*i;
}
int right(int i){ // 计算给定下标的右子树节点
 return 2*i+1;
}
```

除了上述数组下标上的规律以外，你还会发现堆中的每一个节点的值都比左右子树节点大，这被称为**大根堆**，即对于大根堆来说以下一定成立：

```
array[i] > array[left(i)] && array[i] > array[right(i)] == true
```

相应的如果堆中每个一节点的值都比左右子树节点的值小，那么这被称为**小根堆**，即对于小根堆来说以下一定成立：

```
array[i] < array[left(i)] && array[i] < array[right(i)] == true
```

以上就是堆这种数据结构的全部内容了。&#x20;

那么接下来的问题就是，给定一个数组，我们该如何将数组中的值调整成一个堆呢？&#x20;

## 如何在给定数组上创建堆

在这里我们以大根堆为例来讲解如何在给定数组上创建一个堆。&#x20;

给定数组的初始状态如下图a所示，从图中我们看到除array\[2]之外其它所有节点都满足大根堆的要求了，接下来我们要做的就是把array\[2]也调整成为大根堆，那么该怎么调整呢？

![](.gitbook/assets/35\_4.jpg)

![](.gitbook/assets/35\_5.jpg)

很简单，我们只需要将array\[2]和其左右子树节点进行比较，最大的那个和array\[2]进行交换，如图b所示，array\[2]和其左子树array\[4]以及右子树array\[5]中最大的是array\[4]，这样array\[2]和array\[4]进行交换，这样array\[2]就满足大根堆的要求了，如图b所示；

![](.gitbook/assets/35\_6.jpg)

但此时array\[4]不满足要求，怎么办呢？还是重复上面的过程，在array\[4]的左子树和右子树中选出一个最大的和array\[4]交换，最终我们来到了图c，此时所有元素都满足了堆的要求，这个过程就好比石子在水中下沉，一些资料中将这个过程称形象的称为“shift down”。

![](.gitbook/assets/35\_7.jpg)

现在我们知道了假设堆中有一个元素i不满足大根堆的要求，那么该如何调整呢：

```
void keep_max_heap(int i){
 int l = left(i);
 int r = right(i);
 int larget = i;
 if (l < heap_size && array[l] > array[i])
 larget = l;
 if (r < heap_size && array[r] > array[larget])
 larget = r;
 if (larget != i){
 swap(array[larget], array[i]);
 max_heap(larget);
 }
}
```

以上代码即keep\_max\_heap函数就是刚才讲解调整节点的过程，该过程的时间复杂度为O(logn)。&#x20;

但是到目前为止我们依然不知道该如何在给定的数组上创建堆，不要着急，我们首先来观察一下给定的数组的初始状态，如图所示：

![](.gitbook/assets/35\_8.jpg)

实际上堆是一颗完全二叉树，那么这对于我们来说有什么用呢？这个性质非常有用，这个性质告诉我们要想将一个数组转换为堆，我们只需要从第一个非叶子节点开始调整即可。&#x20;

那么第一个非叶子节点在哪里呢？假设堆的大小为heap\_size，那么第一个非叶子节点就是：

```
heap_size / 2;
```

可这是为什么呢？原因很简单，因为第一个非叶子节点总是最后一个节点的父节点，因此第一个非叶子节点就是：

```
parent(heap_size) == heap_size / 2
```

有了这些准备知识就可以将数组转为堆了，我们只需要依次在第一个非叶子节点到第二个节点上调用一下keep\_max\_heap就可以了：

```
parent(heap_size) == heap_size / 2
```

有了这些准备知识就可以将数组转为堆了，我们只需要依次在第一个非叶子节点到第二个节点上调用一下keep\_max\_heap就可以了：

```
void build_max_heap() {
 for (int i = heap_size/2; i>=1; i--)
 keep_max_heap(i);
}
```

这样，一个堆就建成了。










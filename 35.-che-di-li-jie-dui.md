# 35.彻底理解堆

在计算机科学中堆是一种很有趣的数据结构，实际上通常用数组来存储堆中的元素，但是我们却可以把数组中元素视为树，如图所示：

![](.gitbook/assets/35\_1.jpg)

这就是一个普通的数组，但是我们可以将其看做如下图所示的树：

![](.gitbook/assets/35\_2.jpg)

这是怎么做到的呢？&#x20;

原来虽然我们是在数组中存储的堆元素，但是这里面有一条隐藏的规律，如果你仔细看上图就会发现：&#x20;

* **每一个左子树节点的下标是父节点的2倍**
* **每一个右子树节点的下标是父节点的2倍再加1**&#x20;

也就是说在数组中实际上隐藏了上面的这两条规律，如图所示：

![](.gitbook/assets/35\_3.jpg)

**堆这种数据结构最棒的地方在于我们无需像树一样存储左右子树的信息**，而只需要通过下标运算就可以轻松的找到一个节点的左子树节点、右子树节点以及父节点，如下所示，相对于树这种数据结构来说堆更加节省内存。

```
int parent(int i){ // 计算给定下标的父节点
 return i/2;
}
int left(int i){ // 计算给定下标的左子树节点
 return 2*i;
}
int right(int i){ // 计算给定下标的右子树节点
 return 2*i+1;
}
```

除了上述数组下标上的规律以外，你还会发现堆中的每一个节点的值都比左右子树节点大，这被称为**大根堆**，即对于大根堆来说以下一定成立：

```
array[i] > array[left(i)] && array[i] > array[right(i)] == true
```

相应的如果堆中每个一节点的值都比左右子树节点的值小，那么这被称为**小根堆**，即对于小根堆来说以下一定成立：

```
array[i] < array[left(i)] && array[i] < array[right(i)] == true
```

以上就是堆这种数据结构的全部内容了。&#x20;

那么接下来的问题就是，给定一个数组，我们该如何将数组中的值调整成一个堆呢？&#x20;

## 如何在给定数组上创建堆

在这里我们以大根堆为例来讲解如何在给定数组上创建一个堆。&#x20;

给定数组的初始状态如下图a所示，从图中我们看到除array\[2]之外其它所有节点都满足大根堆的要求了，接下来我们要做的就是把array\[2]也调整成为大根堆，那么该怎么调整呢？

![](.gitbook/assets/35\_4.jpg)

![](.gitbook/assets/35\_5.jpg)

很简单，我们只需要将array\[2]和其左右子树节点进行比较，最大的那个和array\[2]进行交换，如图b所示，array\[2]和其左子树array\[4]以及右子树array\[5]中最大的是array\[4]，这样array\[2]和array\[4]进行交换，这样array\[2]就满足大根堆的要求了，如图b所示；

![](.gitbook/assets/35\_6.jpg)

但此时array\[4]不满足要求，怎么办呢？还是重复上面的过程，在array\[4]的左子树和右子树中选出一个最大的和array\[4]交换，最终我们来到了图c，此时所有元素都满足了堆的要求，这个过程就好比石子在水中下沉，一些资料中将这个过程称形象的称为“shift down”。

![](.gitbook/assets/35\_7.jpg)

现在我们知道了假设堆中有一个元素i不满足大根堆的要求，那么该如何调整呢：

```
void keep_max_heap(int i){
 int l = left(i);
 int r = right(i);
 int larget = i;
 if (l < heap_size && array[l] > array[i])
 larget = l;
 if (r < heap_size && array[r] > array[larget])
 larget = r;
 if (larget != i){
 swap(array[larget], array[i]);
 max_heap(larget);
 }
}
```

以上代码即keep\_max\_heap函数就是刚才讲解调整节点的过程，该过程的时间复杂度为O(logn)。&#x20;

但是到目前为止我们依然不知道该如何在给定的数组上创建堆，不要着急，我们首先来观察一下给定的数组的初始状态，如图所示：

![](.gitbook/assets/35\_8.jpg)

实际上堆是一颗完全二叉树，那么这对于我们来说有什么用呢？这个性质非常有用，这个性质告诉我们要想将一个数组转换为堆，我们只需要从第一个非叶子节点开始调整即可。&#x20;

那么第一个非叶子节点在哪里呢？假设堆的大小为heap\_size，那么第一个非叶子节点就是：

```
heap_size / 2;
```

可这是为什么呢？原因很简单，因为第一个非叶子节点总是最后一个节点的父节点，因此第一个非叶子节点就是：

```
parent(heap_size) == heap_size / 2
```

有了这些准备知识就可以将数组转为堆了，我们只需要依次在第一个非叶子节点到第二个节点上调用一下keep\_max\_heap就可以了：

```
parent(heap_size) == heap_size / 2
```

有了这些准备知识就可以将数组转为堆了，我们只需要依次在第一个非叶子节点到第二个节点上调用一下keep\_max\_heap就可以了：

```
void build_max_heap() {
 for (int i = heap_size/2; i>=1; i--)
 keep_max_heap(i);
}
```

这样，一个堆就建成了。

## 增加堆节点以及删除堆节点&#x20;

对于堆这种数据结构来说除了在给定数组上创建出一个堆之外，还需要支持增加节点以及删除节点的操作，在这里我们依然以大根堆为例来讲解，首先来看删除堆节点。&#x20;

## 删除节点&#x20;

删除堆中的一个节点实际用到的正是keep\_max\_heap这个过程，假设删除的是节点i，那么我只需要将节点i和最后一个元素交换，并且在节点i上调用keep\_max\_heep函数就可以了：

```
void delete_heep_node(int i) {
 swap(array[i], array[heap_size]);
 --heap_size;
 keep_max_heap(i);
}
```

注意在该过程中不要忘了将堆的大小减一。&#x20;

## 增加节点&#x20;

增加堆中的一个节点相对容易，如图所示，假设堆中新增了一个节点16，那么该如何位置堆的性质呢？很简单，我们只需要将16和其父节点进行比较，如果不符合要求就交换，并重复该过程直到根节点为止，这个过程就好比水中的气泡上浮，有的资料也将这个过程形象的称为“shift up”，该过程的时间复杂度为O(logn)。

![](.gitbook/assets/35\_9.jpg)

用代码表示就是如下add\_heap\_node函数：

```
void add_heap_node(int i){
 if (i == 0)
 return;
 int p = parent(i);
 if(array[i] > array[p]) {
 swap(array[i], array[p]);
 add_heap_node(p);
 }
}
```

至此，关于堆的性质、堆的创建以及增删就讲解完毕了，接下来我们看一下堆这种数据结构都可以用来做些什么。&#x20;

## 堆的应用&#x20;

在这一节中我们介绍三种堆常见的应用场景。&#x20;

## 排序&#x20;

有的同学可能会有疑问，堆这种数据结构该如何来排序呢？&#x20;

让我们来仔细想一想，对于大根堆来说其性质就是所有节点的值都比其左子树节点和右子树节点的值要大，那么我们很容易得出以下结论，对于大根堆来说：&#x20;

_**堆中的第一个元素就是所有元素的最大值**_。&#x20;

有了这样一个结论就可以将堆应用在排序上了：

1. 将大根堆中的第一个元素和最后一个元素交换&#x20;
2. 堆大小减一&#x20;
3. 在第一个元素上调用keep\_max\_heap维持大根堆的性质

这个过程能进行排序是很显然的，实际上我们就是不断的将数组中的最大值放到数组最后一个位置，次大值放到最大值的前一个位置，利用的就是大根堆的第一个元素是数组中所有元素最大值这个性 质。&#x20;

用代码表示就如下所示：

```
void heap_sort(){
 build_max_heap();
 for(int i=heap_size-1;i>=1;i--){
 swap(array[0],array[i]);
 --heap_size;
 keep_max_heap(0);
 }
}
```










# 11.自己动手实现malloc内存分配器

**对内存分配器透彻理解是编程高手的标志之一。**&#x20;

如果你不能理解malloc之类内存分配器实现原理的话，那你可能写不出高性能程序，写不出高性能程序就很难参与核心项目，参与不了核心项目那么很难升职加薪，很难升级加薪就无法走向人生巅峰，没想到内存分配竟如此关键，为了走上人生巅峰你也要势必读完本文。&#x20;

现在我们知道了，对内存分配器透彻的理解是写出高性能程序的关键所在，那么我们该怎样透彻理解内存分配器呢？

**还有什么能比你自己动手实现一个理解的更透彻吗？**

****![](.gitbook/assets/11\_1.jpg)****

接下来，我们就自己实现一个malloc内存分配器。读完本文后内存分配对你将不再是一个神秘的黑盒。&#x20;

在讲解实现原理之前，我们需要回答一个基本问题，那就是我们为什么要发明内存分配器这种东西。

**内存申请与释放**

程序员经常使用的内存申请方式被称为**动态内存分配**，Dynamic Memory Allocation。我们为什么需要动态的去进行内存分配与释放呢？

答案很简单，因为我们不能**提前知道程序到底需要使用多少内存**。那我们什么时候才能知道呢？答案是只有当程序真的**运行**起来后我们才知道。

![](.gitbook/assets/11\_2.jpg)

这就是为什么程序员需要动态的去申请内存的原因，如果能提前知道我们的程序到底需要多少内存，那么直接知道告诉编译器就好了，这样也不必发明malloc等内存分配器了。

知道了为什么要发明内存分配器的原因后，接下来我们着手实现一个。

**程序员应如何看待内存**

实际上，现代程序员是很幸福的，程序员很少去关心内存分配的问题。作为程序员，可以简单的认为我们的程序独占内存，注意，是独占哦。

![](.gitbook/assets/11\_3.jpg)

写程序时你从来没有关心过如果我们的程序占用过多内存会不会影响到其它程序，我们可以简单的认为每个程序(进程)独占4G内存(32位操作系统)，即使我们的物理内存512M。不信你可以去试试，**在即使只有512M大小的内存上你依然可以申请到2G内存来使用**，可这是为什么呢？关于这个问题我们会在《深入理解操作系统》系列中详细阐述。

总之，程序员可以放心的认为我们的程序运行起来后在内存中是这样的：

![](.gitbook/assets/11\_4.jpg)

作为程序员我们应该知道，内存动态申请和释放都发生在堆区，heap。

我们使用的malloc或者C++中的new申请内存时，就是从堆区这个区域中申请的。&#x20;

接下来我们就要自己管理堆区这个内存区域。&#x20;

堆区这个区域实际上非常简单，真的是非常简单，你可以将其看做一大数组，就像这样：

![](.gitbook/assets/11\_5.jpg)

从内存分配器的角度看，内存分配器根本不关心你是整数、浮点数、链表、二叉树等数据结构、还是对象、结构体等这些花哨的概念，**在内存分配器眼里不过就是一个内存块，这些内存块中可以装入原生的字节序列**，申请者拿到该内存块后可以塑造成整数、浮点数、链表、二叉树等数据结构以及对象、结构体等，这是使用者的事情，和内存分配器无关。&#x20;

我们要在这片内存上解决两个问题：

1. 实现一个malloc函数，也就是如果有人向我申请一块内存，我该怎样从堆区这片区域中找到一块返回给申请者。
2. 实现一个free函数，也就是当某一块内存使用完毕后，我该怎样还给堆区这片区域。

这是内存分配器要解决的两个最核心的问题，接下来我们先去停车场看看能找到什么启示。

### 从停车场到内存管理

实际上你可以把内存看做一条长长的停车场，我们申请内存就是要找到一块停车位，释放内存就是把车开走让出停车位。

![](.gitbook/assets/11\_6.jpg)

只不过这个停车场比较特殊，我们不止可以停小汽车、也可以停占地面积很小的自行车以及占地面积很大的卡车，重点就是申请的内存是大小不一的，在这样的条件下你该怎样实现以下两个目标呢？

* 快速找到停车位，在内存申请中，这涉及到以最大速度找到一块满足要求的空闲内存
* 尽最大程度利用停车场，我们的停车场应该能停尽可能多的车，在内存申请中，这涉及到在给定条件下尽可能多的满足内存申请需求

现在，我们已经清楚的理解任务了，那么该怎么实现呢？

### 任务拆分

现在我们已经明确要实现什么以及衡量其好坏的标准，接下来我们就要去设计实现细节了，让我们把任务拆分一下，怎么拆分呢？&#x20;

我们可以自己想一下从内存的申请到释放需要哪些细节。&#x20;

申请内存时，我们需要在内存中找到一块大小合适的空闲内存分配出去，那么我们怎么知道有**哪些内存块是空闲的呢**？

![](.gitbook/assets/11\_7.jpg)

因此，第一个实现细节出现了，**我们需要把内存块用某种方式组织起来，这样我们才能追踪到每一块内存的分配状态**。&#x20;

现在空闲内存块组织好了，那么一次内存申请可能有很多空闲内存块满足要求，那么我们该选择哪一个空闲内存块分配给用户呢？

![](.gitbook/assets/11\_8.jpg)

因此，第二个实现细节出现了，**我们该选择什么样的空闲内存块给到用户**。&#x20;

接下来我们找到了一块大小合适的内存块，假设用户需要16个字节，而我们找到的这块空闲内存块大小为32字节，那么将16字节分配给用户后还剩下16字节，这剩下的内存该怎么处理呢？&#x20;

因此，第三个实现细节出现了，分配出去内存后，**空闲内存块剩余的空间该怎么处理**？

![](.gitbook/assets/11\_9.jpg)

最后，分配给用户的内存使用完毕，这是第四个细节出现了，**我们该怎么处理用户还给我们的内存呢**？

&#x20;以上四个问题是任何一个内存分配器必须要回答的，接下来我们就一一解决这些问题，解决完这些问题后一个崭新的内存分配器就诞生啦。







****

****

****

****

****

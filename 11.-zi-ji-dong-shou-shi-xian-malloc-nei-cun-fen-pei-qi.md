# 11.自己动手实现malloc内存分配器

**对内存分配器透彻理解是编程高手的标志之一。**&#x20;

如果你不能理解malloc之类内存分配器实现原理的话，那你可能写不出高性能程序，写不出高性能程序就很难参与核心项目，参与不了核心项目那么很难升职加薪，很难升级加薪就无法走向人生巅峰，没想到内存分配竟如此关键，为了走上人生巅峰你也要势必读完本文。&#x20;

现在我们知道了，对内存分配器透彻的理解是写出高性能程序的关键所在，那么我们该怎样透彻理解内存分配器呢？

**还有什么能比你自己动手实现一个理解的更透彻吗？**

****![](.gitbook/assets/11\_1.jpg)****

接下来，我们就自己实现一个malloc内存分配器。读完本文后内存分配对你将不再是一个神秘的黑盒。&#x20;

在讲解实现原理之前，我们需要回答一个基本问题，那就是我们为什么要发明内存分配器这种东西。

**内存申请与释放**

程序员经常使用的内存申请方式被称为**动态内存分配**，Dynamic Memory Allocation。我们为什么需要动态的去进行内存分配与释放呢？

答案很简单，因为我们不能**提前知道程序到底需要使用多少内存**。那我们什么时候才能知道呢？答案是只有当程序真的**运行**起来后我们才知道。

![](.gitbook/assets/11\_2.jpg)

这就是为什么程序员需要动态的去申请内存的原因，如果能提前知道我们的程序到底需要多少内存，那么直接知道告诉编译器就好了，这样也不必发明malloc等内存分配器了。

知道了为什么要发明内存分配器的原因后，接下来我们着手实现一个。

**程序员应如何看待内存**

实际上，现代程序员是很幸福的，程序员很少去关心内存分配的问题。作为程序员，可以简单的认为我们的程序独占内存，注意，是独占哦。

![](.gitbook/assets/11\_3.jpg)

写程序时你从来没有关心过如果我们的程序占用过多内存会不会影响到其它程序，我们可以简单的认为每个程序(进程)独占4G内存(32位操作系统)，即使我们的物理内存512M。不信你可以去试试，**在即使只有512M大小的内存上你依然可以申请到2G内存来使用**，可这是为什么呢？关于这个问题我们会在《深入理解操作系统》系列中详细阐述。

总之，程序员可以放心的认为我们的程序运行起来后在内存中是这样的：

![](.gitbook/assets/11\_4.jpg)

作为程序员我们应该知道，内存动态申请和释放都发生在堆区，heap。

我们使用的malloc或者C++中的new申请内存时，就是从堆区这个区域中申请的。&#x20;

接下来我们就要自己管理堆区这个内存区域。&#x20;

堆区这个区域实际上非常简单，真的是非常简单，你可以将其看做一大数组，就像这样：

![](.gitbook/assets/11\_5.jpg)

从内存分配器的角度看，内存分配器根本不关心你是整数、浮点数、链表、二叉树等数据结构、还是对象、结构体等这些花哨的概念，**在内存分配器眼里不过就是一个内存块，这些内存块中可以装入原生的字节序列**，申请者拿到该内存块后可以塑造成整数、浮点数、链表、二叉树等数据结构以及对象、结构体等，这是使用者的事情，和内存分配器无关。&#x20;

我们要在这片内存上解决两个问题：

1. 实现一个malloc函数，也就是如果有人向我申请一块内存，我该怎样从堆区这片区域中找到一块返回给申请者。
2. 实现一个free函数，也就是当某一块内存使用完毕后，我该怎样还给堆区这片区域。

这是内存分配器要解决的两个最核心的问题，接下来我们先去停车场看看能找到什么启示。

### 从停车场到内存管理

实际上你可以把内存看做一条长长的停车场，我们申请内存就是要找到一块停车位，释放内存就是把车开走让出停车位。

![](.gitbook/assets/11\_6.jpg)

只不过这个停车场比较特殊，我们不止可以停小汽车、也可以停占地面积很小的自行车以及占地面积很大的卡车，重点就是申请的内存是大小不一的，在这样的条件下你该怎样实现以下两个目标呢？

* 快速找到停车位，在内存申请中，这涉及到以最大速度找到一块满足要求的空闲内存
* 尽最大程度利用停车场，我们的停车场应该能停尽可能多的车，在内存申请中，这涉及到在给定条件下尽可能多的满足内存申请需求

现在，我们已经清楚的理解任务了，那么该怎么实现呢？

### 任务拆分

现在我们已经明确要实现什么以及衡量其好坏的标准，接下来我们就要去设计实现细节了，让我们把任务拆分一下，怎么拆分呢？&#x20;

我们可以自己想一下从内存的申请到释放需要哪些细节。&#x20;

申请内存时，我们需要在内存中找到一块大小合适的空闲内存分配出去，那么我们怎么知道有**哪些内存块是空闲的呢**？

![](.gitbook/assets/11\_7.jpg)

因此，第一个实现细节出现了，**我们需要把内存块用某种方式组织起来，这样我们才能追踪到每一块内存的分配状态**。&#x20;

现在空闲内存块组织好了，那么一次内存申请可能有很多空闲内存块满足要求，那么我们该选择哪一个空闲内存块分配给用户呢？

![](.gitbook/assets/11\_8.jpg)

因此，第二个实现细节出现了，**我们该选择什么样的空闲内存块给到用户**。&#x20;

接下来我们找到了一块大小合适的内存块，假设用户需要16个字节，而我们找到的这块空闲内存块大小为32字节，那么将16字节分配给用户后还剩下16字节，这剩下的内存该怎么处理呢？&#x20;

因此，第三个实现细节出现了，分配出去内存后，**空闲内存块剩余的空间该怎么处理**？

![](.gitbook/assets/11\_9.jpg)

最后，分配给用户的内存使用完毕，这是第四个细节出现了，**我们该怎么处理用户还给我们的内存呢**？

&#x20;以上四个问题是任何一个内存分配器必须要回答的，接下来我们就一一解决这些问题，解决完这些问题后一个崭新的内存分配器就诞生啦。

### 管理空闲内存块

空闲内存块的本质是需要某种办法来来区分哪些是空闲内存哪些是已经分配出去的内存。&#x20;

有的同学可能会说，这还不简单吗，用一个链表之类的结构记录下每个空闲内存块的开始和结尾不就可以了，这句话也对也不对。

![](.gitbook/assets/11\_10.jpg)

说不对，是因为如果要申请内存来创建这个链表那么这就是不对的，原因很简单，因为创建链表不可避免的要申请内存，申请内存就需要通过内存分配器，可是你要实现的就是一个内存分配器，**你没有办法向一个还没有实现的内存分配器申请内存**。

![](.gitbook/assets/11\_11.jpg)

说对也对，我们确实需要一个类似链表这样的结构来维护空闲内存块，但这个链表并不是我们常见的那种。&#x20;

因为我们无法将空闲内存块的信息保存在其它地方，那么没有办法，**我们只能将维护内存块的分配信息保存在内存块本身中**，这也是大多数内存分配器的实现方法。&#x20;

那么，为了维护内存块分配状态，我们需要知道哪些信息呢？很简单：

* 一个标记，用来标识该内存块是否空闲
* 一个数字，用来记录该内存块的大小

为了简单起见，我们的内存分配器不对内存对齐有要求，同时一次内存申请允许的最大内存块为2G，**注意，这些假设是为了方便讲解内存分配器的实现而屏蔽一些细节，我们常用的malloc等不会有这样的限制。**

因为我们的内存块大小上限为2G，因此我们可以使用31个比特位来记录块大小，剩下的一个比特位用来标识该内存块是空闲的还是已经被分配出去了，下图中的f/a是free/allocate，也就是标记是已经分配出去还是空闲的。这32个比特位就是header，用来存储块信息。

![](.gitbook/assets/11\_12.jpg)

**剩下的灰色部分才是真正可以分配给用户的内存**，这一部分也被称为负载，payload，**我们调用malloc返回的内存起始地址正是这块内存的起始地址**。&#x20;

现在你应该知道了吧，不是说堆上有10G内存，这里面就可以全部用来存储数据的，这里面必然有一部分要拿出来维护内存块的一些信息，就像这里的header一样。

### 跟踪内存分配状态

有了上图，我们就可以将堆这块内存区域组织起来并进行内存分配与释放了，如图所示：

![](.gitbook/assets/11\_13.jpg)

在这里我们的堆区还很小，每一方框代表4字节，其中红色区域表示已经分配出去的，灰色区域表示空闲内存，每一块内存都有一个header，用带斜线的方框表示，比如16/1，就表示该内存块大小是16字节，1表示已经分配出去了；而32/0表示该内存块大小是32字节，0表示该内存块当前空闲。&#x20;

细心的同学可能会问，那最后一个方框0/1表示什么呢？原来，我们需要某种特殊标记来告诉我们的内存分配器是不是已经到末尾了，这就是最后4字节的作用。&#x20;

通过引入header我们就能知道每一个内存块的大小，从而可以很方便的遍历整个堆区。遍历方法很简单，因为我们知道每一块的大小，那么从当前的位置加上当前块的大小就是下一个内存块的起始位置，如图所示：

****![](.gitbook/assets/11\_14.jpg)****

通过每一个header的最后一个bit位就能知道每一块内存是空闲的还是已经分配出去了，这样我们就能追踪到每一个内存块的分配信息，因此上文提到的第一个问题解决了。&#x20;

接下来我们看第二个问题。

### 怎样选择空闲内存块

当应用程序调用我们实现的malloc时，内存分配器需要遍历整个空闲内存块找到一块能满足应用程序要求的内存块返回，就像下图这样：

![](.gitbook/assets/11\_15.jpg)

假设应用程序需要申请4字节内存，从图中我们可以看到有两个空闲内存块满足要求，第一个大小为8字节的内存块和第三个大小为32字节的内存块，那么我们到底该选择哪一个返回呢？这就涉及到了分配策略的问题，实际上这里有很多的策略可供选择。

First Fit



****

****

****

****

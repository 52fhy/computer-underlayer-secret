# 2.你管这破玩意叫线程？

#### 一起要从CPU说起

你可能会有疑问，讲多线程为什么要从CPU说起呢？原因很简单，**在这里没有那些时髦的概念，你可 以更加清晰的看清问题的本质**。

CPU并不知道线程、进程之类的概念。

CPU只知道两件事:

1. 从内存中取出指令
2. 执行指令，然后回到1

![](.gitbook/assets/2\_1.jpg)

你看，在这里CPU确实是不知道什么进程、线程之类的。

接下来的问题就是CPU从哪里取出指令呢？答案是来自一个被称为Program Counter(简称PC)的寄存 器，也就是我们熟知的程序计数器，在这里大家不要把寄存器想的太神秘，你可以简单的把寄存器理 解为内存，只不过存取速度更快而已。

PC寄存器中存放的是什么呢？这里存放的是指令在内存中的地址，什么指令呢？是CPU将要执行的下 一条指令。

![](.gitbook/assets/2\_2.jpg)

那么是谁来设置PC寄存器中的指令地址呢？

原来PC寄存器中的地址默认是自动加1的，这当然是有道理的，因为大部分情况下CPU都是一条接一 条顺序执行，当遇到if、else时，这种顺序执行就被打破了，CPU在执行这类指令时会根据计算结果 来动态改变PC寄存器中的值，这样CPU就可以正确的跳转到需要执行的指令了。

聪明的你一定会问，那么PC中的初始值是怎么被设置的呢？

在回答这个问题之前我们需要知道CPU执行的指令来自哪里？是来自内存，废话，内存中的指令是从 磁盘中保存的可执行程序加载过来的，磁盘中可执行程序是编译器生成的，编译器又是从哪里生成的 机器指令呢？答案就是**我们定义的函数**。

![](.gitbook/assets/2\_3.jpg)

注意是函数，**函数被编译后才会形成CPU执行的指令**，那么很自然的，我们该如何让CPU执行一个函 数呢？显然我们只需要找到函数被编译后形成的第一条指令就可以了，第一条指令就是函数入口。

现在你应该知道了吧，我们想要CPU执行一个函数，那么**只需要把该函数对应的第一条机器指令的地 址写入PC寄存器就可以了**，这样我们写的函数就开始被CPU执行起来啦。

你可能会有疑问，这和线程有什么关系呢？

#### 从CPU到操作系统

上一小节中我们明白了CPU的工作原理，我们想让CPU执行某个函数，那么只需要把函数对应的第一 条机器执行装入PC寄存器就可以了，**这样即使没有操作系统我们也可以让CPU执行程序**，虽然可行但 这是一个非常繁琐的过程，我们需：

* 在内存中找到一块大小合适的区域装入程序
* 找到函数入口，设置好PC寄存器让CPU开始执行程序

这两个步骤绝不是那么容易的事情，如果每次在执行程序时程序员自己手动实现上述两个过程会疯掉 的，因此聪明的程序员就会想干脆直接写个程序来自动完成上面两个步骤吧。

机器指令需要加载到内存中执行，因此需要记录下内存的起始地址和长度；同时要找到函数的入口地 址并写到PC寄存器中，想一想这是不是需要一个数据结构来记录下这些信息：

```
struct *** {
   void* start_addr;
   int len;
  
   void* start_point;
};
```

接下来就是起名字时刻。

这个数据结构总要有个名字吧，干脆就叫**进程(Process)**好了，我们的指导原则就是一定要听上去比 较神秘，总之大家都不容易弄懂就对了，我将其称为“弄不懂原则”。

就这样进程诞生了。

CPU执行的第一个函数也起个名字，第一个要被执行的函数听起来比较重要，干脆就叫main函数吧。&#x20;

完成上述两个步骤的程序也要起个名字，根据“弄不懂原则”这个“简单”的程序就叫操作系统 (Operating System)好啦。

就这样操作系统诞生了，程序员再也不用自己手动加载可执行程序了。&#x20;

现在进程和操作系统都有了，一切看上去都很完美。

#### 从单核到多核，如何充分利用多核&#x20;

人类的一大特点就是生命不息折腾不止，从单核折腾到了多核。&#x20;

这时，假设我们想写一个程序并且要分利用多核该怎么办呢？&#x20;

有的同学可能会说不是有进程吗，多开几个进程不就可以了？听上去似乎很有道理，但是主要存在这 样几个问题：

* 进程是需要占用内存空间的(从上一节能看到这一点)，如果多个进程基于同一个可执行程序，那 么这些进程其内存区域中的内容几乎完全相同，这显然会造成内存的浪费
* 计算机处理的任务可能是比较复杂的，这就涉及到了进程间通信，由于各个进程处于不同的内存 地址空间，进程间通信天然需要借助操作系统，这就在增大编程难度的同时也增加了系统开销

该怎么办呢？

#### 从进程到线程&#x20;

让我再来仔细的想一想这个问题，所谓进程无非就是内存中的一段区域，这段区域中保存了CPU执行 的机器指令以及函数运行时的堆栈信息，要想让进程运行，就把main函数的第一条机器指令地址写 入PC寄存器，这样进程就运行起来了。

![](.gitbook/assets/2\_4.jpg)

进程的缺点在于只有一个入口函数，也就是main函数，因此进程中的机器指令**只能被一个CPU执行**，那么有没有办法让多个CPU来执行同一个进程中的机器指令呢？

聪明的你应该能想到，既然我们可以把main函数的第一条指令地址写入PC寄存器，那么其它函数和 main函数又有什么区别呢？

答案是没什么区别，main函数的特殊之处无非就在于是CPU执行的第一个函数，除此之外再无特别之 处，**我们可以把PC寄存器指向main函数，就可以把PC寄存器指向任何一个函数**。

**当我们把PC寄存器指向非main函数时，线程就诞生了。**

****![](.gitbook/assets/2\_5.jpg)****

至此我们解放了思想，一个进程内可以有多个入口函数，也就是说属于同一个进程中的机器指令可以被多个CPU同时执行。

